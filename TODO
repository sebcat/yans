- scanny: --limit-nsubjects=${N} - before, after resolve
  or maybe not, could be that we should accept an arbitrary large number
  of subjects, limited only by disk and execution time.
- store list <store-id> - pass dir-fd from stored and have client list store?
- pass fopen-style mode string to store instead of flags, have the mode string
  copied to the Lua file descriptor type and make it possible to write
  foo:open("trololo", "rb"):to_stream() without passing the mode string to
  to_stream

- yans-fe: If 1) is selected, then 2) then 1) again: report entries are
  appended. Make them replace instead of append

- Currently, a hard restart prevents services from starting again due to
  existing PID-files. Clean pidfiles on service start (potential issues
  if service is started two times?)
- Do not wait while shutting down a service if all children are terminated
- store index --name-must-match?

- n/a, queued, started, completed - how to differentiate?
  kneg status <id>
  1)
    * queue_knegd_job: queued
    * start_knegd_job: started
    * kng_on_svc_reaped_child: completed
    * everything else: n/a
    * store status as file in store
    * job_update_status(kng_job *s, const char *status);
  2)
    * queued, started, inactive - Have knegd keep state of queued and
      started jobs and consider everything else "inactive"
      (n/a or completed)
    * symlink e.g., queue/ids/31/abcdedaaff1231 -> queue/45/01234567-1
      and implement int kngq_contains(struct kng_queue *q, const char *id);
      kngq_put: Add symlink
      kngq_next: Remove symlink
    * if kngq_contains, status: queued
      else if jobs_find_by_id != NULL: started
      else: inactive
  1) requires IPC and harder coupling with store, 2) is less coupled with
  store, however we do not know if something is queued or not
- sync index vs job.json times - queued or started? Maybe no duplication?
- have yansapi use "queue" instead of "start" action

## ethd
  - interfaces and stuff are loaded at boot, may change during uptime

## lua
  - receive/transmit buffers for fd
  - event driven poll
  - callback system in lua, similar to eds. on_next_fd, on_readable,
    on_writable, on_done

Events = require "file.events" -- poll wrapper
FooDriver = {...} -- load like: require"drivers.foo"
function FooDriver:new{...} ... end
function FooDriver:register(ev) ... end
function FooDriver:on_next_fd() ... end
function FooDriver:on_readable(ev, fd) ... end
function FooDriver:on_writable(ev, fd) ... end
function FooDriver:on_eval_error(ev, fd) ... end
function FooDriver:on_done(ev, fd) ... end
Events:new{
  nconcurrent = 10,
  nsec_timeout = 10,
  driver = FooDriver:new{...},
}:run()

Buffer = require"yans.file.buf"
buf = Buffer:new{initial = ..., max = ...}
nread, err = fd:read(buf)
nleft, err = fd:write(buf)
ev:register(
ev:clear_actions(fd)
ev:set_on_readable(fd, rfunc)
ev:set_on_writable(fd, wfunc)
ev:clear_on_readable(fd)
ev:clear_on_writable(fd)

## ethframe
  - SSDP, MDNS, ICMP multicasts
  - choose sequential/procedurally generated/PRNG source port within suitable
    range instead of hard-coding?
  - generate packet generators from DSL?
  - only have ethframe distribute /dev/bpf sockets, rip out the frame
    generation to a library called from lua (preferably DSL generated)
    or maybe not - too many ethernet writer processes are maybe bad?
    some MAC checks, &c. If that is a problem, it could be mitigated in the
    kernel, using a custom devfs-node for accessing the NIC directly

## lib/net/url
  - url_normalize: if we have a percent-encoding to a valid char, decode it?

## lib/net/ip
  - make it possible to add/remove an address/range to/from a range
  - have contains work on current instead of first?

## new services

  - bannerd: UDP/TCP banner grabbing with (D)TLS support (libressl?)
  - tlshellod: TLS negotiation w/ STARTTLS
  - spiderd: HTTP crawler (or HTTP proxy?)
    * have a file with requests (raw HTTP requests?), pass it to the daemon
      which generates a file with responses. Parse responses and generate new
      requests. How to find requests? Have identity hash mapped to offsets?

## distribution
  - Yocto linux based? NanoBSD based?( XXX NanoBSD is obsolete) Homebrewn
    FreeBSD dist?
  - .vmdk image
  - read-only fs
  - /var/yans as tmpfs/md(4)
  - nginx
  - /usr/share/www/a1
  - API implemented as yans CGIs, with implicit seccomp-bpf/capsicum
    on cgi.init

more areas:
  protocols: dns, ssh, ftp, http, smtp, pop3, imap, vnc, rdp
  functionality: enumeration of capabilities (cipher suites, commands, &c)
                 default account testing

## slask

for E in $(store list); do store list $E; done | cut -f 1 -d ' ' | paste -s -d+ - | bc

tcpdump -n '(ether broadcast or ether multicast or ether dst 00:24:d7:17:9c:38) and (not ether src 00:24:d7:17:9c:38)'

tcpdump -n 'ether src not <local0> and ether src not <local1> ... and ether src not <localN>'

echo -en 'M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: ssdp:discover\r\nMX: 10\r\nST: ssdp:all\r\nUser-Agent: DinMammaOchDanHarmon/1.0 UPnP/1.1\r\n\r\n' | socat stdio udp4-datagram:239.255.255.250:1900

echo -en 'M-SEARCH * HTTP/1.1\r\nHOST: [FF02::C]:1900\r\nMAN: ssdp:discover\r\nMX: 10\r\nST: ssdp:all\r\nUser-Agent: DinMammaOchDanHarmon/1.0 UPnP/1.1\r\n\r\n' | socat stdio 'udp6-datagram:[FF02::C%wlan0]:1900'
