#!/usr/bin/env yans
-- vim: syntax=lua :

Resolver     = require"svcs.resolver"
Store        = require"svcs.store"
Netconf      = require"svcs.netconf"
FS           = require"fs"
Subjects     = require"subjects"
YCFG         = require"ycfg"


local function load_config(opener, path)
  local cfg = {
    subjects = "",
  }

  if path then
    local f = opener:open(path, "rb"):to_stream("rb")
    local jin = json.from_str(f:read("a"))
    f:close()

    cfg.subjects = jin.subjects or jin.subject or ""  
  end

  return cfg
end

local function init_services(store_id)
  -- setup service connections
  local services = {}
  local msgbuf = yans.ycl.msgbuf()
  if store_id then
    services.store = Store:new{msgbuf = msgbuf, path = YCFG.SVC_STORE}
    services.store:enter{id=store_id}
  end
  services.opener = FS:new{store = services.store}
  services.resolver = Resolver:new{
    msgbuf = msgbuf,
    path   = YCFG.SVC_RESOLVER,
    opener = services.opener,
  }
  services.netconf = Netconf:new{path = YCFG.SVC_NETCONF,
      msgbuf = msgbuf}:get_netconf()
  return services
end


-- parse command line parameters
local p = yans.opts:new()
p:str("config", "c", "configuration file")
p:str("store-id", "s", "store ID")
p:flag("no-sandbox", "X", "run without sandbox")
p:flag("help", "h", "this text")
local params = p:parse(args)
if params.help then
  io.stdout:write(p:usage())
  os.exit(1)
end


local services = init_services(params["store-id"])

-- sandbox if we have a store
if services.store then
  yans.util.sandbox()
elseif params["no-sandbox"] then
  print("WARNING: sandboxing disabled")
else
  print("No store specified with sandboxing enabled, quitting")
  os.exit(1)
end

local cfg = load_config(services.opener, params.config)

--[[
function rp(node, depth)
  depth = depth or 0
  if type(node) == "table" then
    for k,v in pairs(node) do
      print(string.format("%s%s", string.rep("\t", depth), k))
      rp(v, depth + 1)
    end
  else
    print(string.format("%s%s", string.rep("\t", depth), node))
  end
end

rp(services.netconf)
]]--

local subjects = Subjects:new{
    resolver   = services.resolver,
    netconf    = services.netconf,
}
local res = services.opener:open("subjects.csv.gz", "zlib:wb")
res = res:to_stream("zlib:wb")
subjects:resolve(res, cfg.subjects)
res:close()
services.opener:rename("subjects.csv.gz", "report-10-subjects.csv.gz")

files = {
  {"noshowpls.txt", "wb", "pls no show"},
  {"report-11-s.txt", "wb", cfg.subjects},
  {"report-51-ports.txt.gz", "zlib:wb", "This is the bar report"},
  {"report-20-services.csv", "wb", "foo,bar,baz\n1,2,3"},
  {"report-33-products.csv.gz", "zlib:wb", "baz,bar,foo\n3,2,1\n"},
}

for _, f in pairs(files) do
  local s = services.opener:open(f[1]..".tmp", f[2]):to_stream(f[2])
  s:write(f[3])
  s:close()
  services.opener:rename(f[1]..".tmp", f[1])
end



