#!/usr/bin/env yans
local DAEMON_NAME = "yansapi"
local JAPI        = require "japi"
local Store       = require "svcs.store"

local function atoi(s, def)
  return math.floor(tonumber(s) or def)
end

local function clamp(val, min, max)
  return math.max(math.min(val, max), min)
end

local function clean_id(str)
  if type(str) == "string" then
    local id = str:match("[0-9a-f]+")
    if id:len() == 20 then
      return id
    end
  end
end

local function get_reports(ctx)
  --[[
  GET /a1/reports

  URL Parameters:
    - nelems (opt): Number of elements to fetch. Range: 0 <= nelems <= 100.
                    default: 25
    - before (opt): Fetch indices before a given row.

  Response object on success:
  {
    "success": true,
    "data": [
      {
        "row": 0,
        "ts": 1530356368,
        "id": "70a7a85d0004f8b9c2be"
      },
      ...
    ]
  }
  ]]--

  -- parse the request parameters, provide sane defaults and limits
  local params = ctx:parse_query_string(ctx.query_string)
  local nelems = clamp(atoi(params.nelems, 25), 0, 100)
  local before = math.max(atoi(params.before, 0), 0)

  -- build the response 
  local res = json.from_str"{}"
  local rows = json.from_str"[]"
  for _, e in ipairs(ctx.data.store:index():get(nelems,before)) do
    local entry = json.from_str"{}"
    entry.id, entry.ts, entry.row = e[1], e[2], e[3]
    rows = rows << entry
  end
  res.success = true
  res.data = rows

  -- send the response
  ctx:status"200 OK"
  ctx:write(tostring(res))
end

local function get_report_sections(ctx)
  --[[
  GET /a1/report-sections

  URL Parameters:
    - id (opt): ID of the given report. If omitted, returns empty 'data'.
    - mm (opt): must match FIXME: remove from external API when done testing

  Response object on success:
  {
    "success": true,
    "data": [
      {
        "name": "str",
        "size": 0
      },
      ...
    ]
  }
  ]]--

  -- parse request
  local params = ctx:parse_query_string(ctx.query_string)
  local id     = clean_id(params.id)
  local mm     = params.mm

  -- build response
  local data = json.from_str"[]"
  if id then
    for _, e in ipairs(ctx.data.store:list(id, mm)) do
      local entry = json.from_str"{}"
      entry.name = e
      data = data << entry
    end
  end
  local res   = json.from_str"{}"
  res.success = true
  res.data    = data

  -- send response
  ctx:status"200 OK"
  ctx:write(tostring(res))
end

local function get_fail(ctx)
  error("get fail called")
end

local function handle_fail(fn)
  --[[
  pcall's fn, logs and responds with the proper JSON on failure

  Response object:
  {
    "success": false,
    "errmsg": "str"
  }
  ]]--
  return function(ctx)
    local ok, err = pcall(fn, ctx)
    if not ok then
      yans.ylog.error("request failure: %s", err)
      ctx:status"200 OK" -- all well that ends well, is it not?
      ctx:write'{"success":false,"errmsg":"An internal error occurred, sorry for the inconvenience"}'
    end
  end
end

JAPI:routes{
  ["GET /a1/reports"]          = handle_fail(get_reports),
  ["GET /a1/report-sections"]  = handle_fail(get_report_sections),
  ["GET /a1/fail"]             = handle_fail(get_fail),
}

-- returns a table that will end up in ctx.data in the handlers. Used to
-- setup pre-sandbox stuff
local function prehook()
  local msgbuf = yans.ycl.msgbuf()
  -- FIXME: Store path varies depending on chroot/no chroot
  local store = Store:new{path = "stored/stored.sock", msgbuf = msgbuf}
  return {store = store}
end

-- parse command line options as parameters
local p = yans.opts:new()
p:str("user", "u", "daemon user")
p:str("group", "g", "daemon group")
p:str("basepath", "b", "daemon basepath")
p:flag("no-daemon", "n", "do not daemonize")
p:flag("help", "h", "this text")
local params = p:parse(args)
if params.help then
  io.stdout:write(p:usage())
  os.exit(1)
end

-- set default parameter values
params.user = params.user or "yansapi"
params.group = params.group or "yans"
params.basepath = params.basepath or "/var/yans"

-- since the daemon chroots, the paths will be different
local serve_path
if params["no-daemon"] then
  serve_path = params.basepath.."/"..DAEMON_NAME..".sock"
else
  serve_path = DAEMON_NAME..".sock"
end

-- create the sc2 server
local server = {
  path = serve_path,
  servefunc = function()
    JAPI:dispatch(prehook())
  end,
  donefunc = function(pid, duration, cause, code)
    local fmt = "served request pid:%d duration:%fs %s %d"
    local msg = string.format(fmt, pid, duration, cause, code)
    if cause == "exit" and code == 0 then
      yans.ylog.info(msg)
    else
      yans.ylog.error(msg)
    end
  end,
  errfunc = function(err)
    yans.ylog.error("serve error: %s", tostring(err))
  end,
}

-- Always log to syslog, since we don't want any logs in the children to end
-- up in the HTTP responses
yans.ylog.init(DAEMON_NAME, yans.ylog.SYSLOG)

if not params["no-daemon"] then
  yans.util.daemonize(DAEMON_NAME, params.basepath, params.user, params.group)
end

-- OK, let's do this!
yans.ylog.info("Starting "..DAEMON_NAME)
local serve_ok, serve_err = pcall(yans.sc2.serve, server)

-- Remove the PID-file if we're in daemon mode
if not params["no-daemon"] then
  yans.util.daemon_remove_pidfile(DAEMON_NAME, params.basepath)
end

-- Error out if sc2.serve failed
if not serve_ok then
  error(serve_err)
end
