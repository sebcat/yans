local _M = {
  OK           = "200 OK",
  BAD_REQUEST  = "400 Bad Request",
  NOT_FOUND    = "404 Not Found",
  SERVER_ERROR = "500 Internal Server Error",
  headers      = {},
}

function _M:flush()
  io.stdout:flush()
end

function _M:croak(status, reason)
  self:status(status)
  self:header("X-Reason", reason)
  self:send_header_once()
  os.exit(1)
end

function _M:percent_decode(s)
  -- + -> space is the form-data thingy, shouldn't be used for URLs
  return s:gsub('%%(%x%x)', function(h)
      return string.char(tonumber(h, 16)) end)
end

-- NB: overwrites duplicate keys
function _M:parse_query_string(s)
  local res = {}
  for k in s:gmatch('([^&]+)') do
    for kk, vv in k:gmatch('([^=]+)(.*)') do
      res[self:percent_decode(kk)] = self:percent_decode(vv:sub(2))
    end
  end
  return res
end

function _M:status(s)
  self.statusline = s:gsub("[\r\n\t\0 ]+", " ")
end

function _M:header(key, val)
  key = key:gsub("[\r\n\t\0]+", " ")
  val = val:gsub("[\r\n\t\0]+", " ")
  if key == "Content-Type" then
    self.content_type = val
  elseif key ~= "Status" then
    table.insert(self.headers, string.format("%s: %s", key, val))
  end
end

function _M:send_header_once()
  if self.has_sent_header then
    self:flush() -- always flush for consistency
    return
  end

  if not self.statusline then
    self.statusline = self.OK
  end

  if not self.content_type then
    self.content_type = "application/json"
  end

  table.sort(self.headers) -- sort the headers for consistency
  if #self.headers > 0 then
    io.stdout:write(string.format("Status: %s\r\nContent-Type: %s\r\n%s\r\n\r\n",
        self.statusline, self.content_type, table.concat(self.headers, "\r\n")))
  else
    io.stdout:write(string.format("Status: %s\r\nContent-Type: %s\r\n\r\n",
        self.statusline, self.content_type))
  end
  self:flush()

  self.has_sent_header = true
end

function _M:write(data)
  self:send_header_once()
  data = tostring(data)
  io.stdout:write(data)
end

function _M:routes(r)
  self.route_table = r
end

function _M:dispatch(data)
  -- enter sandbox
  yans.util.sandbox()

  -- make sure we have a route table
  if not self.route_table then
    self:croak(self.SERVER_ERROR, "no route table")
  end

  -- read the request headers and body
  local ok, hdrs, body = pcall(yans.scgi.read_request)
  if not ok then
    self:croak(self.SERVER_ERROR, "read request failure")
  end

  -- Put all headers in a lookup table. Certain headers can occur multiple
  -- times in a request (e.g., HTTP_COOKIE). This only saves the latest of a
  -- header with a given key/name.
  local hdrmap = {}
  for i = 1, #hdrs, 2 do
    hdrmap[hdrs[i]] = hdrs[i + 1]
  end

  -- parse the body, if any, as JSON and require its content type to be set
  if body and #body > 0 then
    local content_type = hdrmap["CONTENT_TYPE"]
    if not content_type then
      self:croak(self.BAD_REQUEST, "missing content type")
    elseif not content_type:find("application/json") then
      self:croak(self.BAD_REQUEST, "invalid content type")
    end
    local ok, res = pcall(json.from_str, body)
    if not ok then
      self:croak(self.BAD_REQUEST, "request body parse failure")
    end
    body = res
  end

  -- make sure we have a method and a path
  local request_method = hdrmap["REQUEST_METHOD"]
  local document_uri = hdrmap["DOCUMENT_URI"]
  if not request_method then
    self:croak(self.BAD_REQUEST, "no method")
  elseif not document_uri then
    self:croak(self.BAD_REQUEST, "no path")
  end

  -- resolve the handler for the request, if any
  local route_key = string.format("%s %s", request_method, document_uri)
  local handler = self.route_table[route_key]
  if not handler then
    self:croak(self.NOT_FOUND, "no handler")
  end

  -- create the responder and call the handler
  local responder = {
    req_hdrs = hdrs,
    req_body = body,
    hdrmap = hdrmap,
    headers = {},        -- response headers
    statusline = nil,    -- filled in later, defaults to "200 OK"
    content_type = nil,  -- filled in later, defaults to "application/json"
    has_sent_header = false,
    query_string = hdrmap["QUERY_STRING"] or "",
    data = data,
  }
  self.__index = self
  setmetatable(responder, self)
  ok, err = pcall(handler, responder)
  if not ok then
    self:croak(self.SERVER_ERROR, "handler failure: " .. err)
  end

  -- make sure we have sent everything
  responder:send_header_once()

  -- exit gracefully
  os.exit(0)
end

return _M
