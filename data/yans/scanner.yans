
local _M = {
  PPS = 300,
}

local Netconf = require"svcs.netconf"
local Store = require"svcs.store"
local YCFG = require"ycfg"

function _M:new(o)
  o = o or {}
  local ycl = yans.ycl
  o.msgbuf = ycl.msgbuf()
  o.netconf = Netconf:new{path = YCFG.SVC_NETCONF, msgbuf = o.msgbuf}
  o.store = Store:new{path = YCFG.SVC_STORE, msgbuf = o.msgbuf}
  o.ethframe_sock = ycl.connect(YCFG.SVC_ETHFRAME)
  o.pcap_sock = ycl.connect(YCFG.SVC_PCAP)
  setmetatable(o, self)
  self.__index = self
  return o
end

function _M:get_netconf()
  return self.netconf:get_netconf()
end

function _M:store_enter(store_id)
  return self.store:enter(store_id)
end

function _M:store_open(path, flags)
  return self.store:open(path, flags)
end

function _M:pcap_start(fd, iface, filter)
  self.msgbuf:create_pcap_req{
    iface = iface,
    filter = filter,
  }
  self.pcap_sock:sendfd(fd)
  self.pcap_sock:sendmsg(self.msgbuf)
  self.pcap_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
  fd:close()
end

function _M:pcap_stop()
  self.msgbuf:create_pcap_close{}
  self.pcap_sock:sendmsg(self.msgbuf)
  self.pcap_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
end

function _M:send_packets(opts)
  opts.pps = opts.pps or self.PPS
  self.msgbuf:create_ethframe_req(opts)
  self.ethframe_sock:sendmsg(self.msgbuf)
  self.ethframe_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
end

return _M
