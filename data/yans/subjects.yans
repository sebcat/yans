--[[

The goal of this code is to take a string consisting of whitespace
separated IPv[46] ranges (where a single address is also considered to be a
range) or domain name(s) and map to a
(iface,src-hwaddr,srcip,nexthop-hwaddr,nexthop-ip,dstip,name)-tuple. In
doing so, zero or more network actions may be performed.

The first part of this procedure, ns_resolve, is to map domain name(s) to IP
address(es). ns_resolve also punycodes name(s). After this step, we have a
sequence of (dstip,name)-tuples, where 'name' can be nil.

Next up we have src_map, which maps the iface, src-hwaddr and srcip to use
for the dstip.

After that we have nexthop_map, which tries to map the next hop.

For unknown next hops in nexthop_map, we have nexthop_resolve which tries to
resolve the next hop, and also updates. nexthop_resolve lookups are batched and
needs to be flushed at the end.

             (netconf, subjects)
                    |
                    v
               +----------+
               |ns_resolve|
               +----------+
                    |
                    |  (netconf, dstip,name)
                    v
                +-------+
                |src_map|
                +-------+
                    |
                    |  (netconf, iface, src-hwaddr, srcip, dstip, name)
                    v
              +-----------+       +---------------+
              |nexthop_map|------>|nexthop_resolve|
              +-----------+       +---------------+
                    |                     |
                    +----------+----------+
                               |
                               v
   (netconf, iface, src-hwaddr, srcip, nexthop-hwaddr, nexthop-ip, dstip, name)
]]--
--[[
function rp(node, depth)
  depth = depth or 0
  if type(node) == "table" then
    for k,v in pairs(node) do
      print(string.format("%s%s", string.rep("\t", depth), k))
      rp(v, depth + 1)
    end
  else
    print(string.format("%s%s", string.rep("\t", depth), node))
  end
end

netconf = require"svcs.netconf":new{...}:get_netconf()
rp(netconf)

em0
        ethaddr
                5c:ff:35:03:08:07
        ip_gws
                1
                        addr
                                155.4.38.81
                        subnet
                                0.0.0.0-255.255.255.255
        ip_srcs
                1
                        addr
                                fe80::5eff:35ff:fe03:807%em0
                        subnet
                                fe80::%em0-fe80::ffff:ffff:ffff:ffff%em0
                2
                        addr
                                155.4.38.87
                        subnet
                                155.4.38.80-155.4.38.95
        ip_neigh
                155.4.38.81
                        f8:98:ef:a3:68:df
        ip_dsts
                1
                        155.4.38.87
                2
                        155.4.38.80-155.4.38.95
                3
                        fe80::5eff:35ff:fe03:807%em0
                4
                        fe80::%em0-fe80::ffff:ffff:ffff:ffff%em0


]]--

local CSV = require"csv"
local NEXTHOP_BUFSZ = 4

_M = {}

function _M:new(o)
  o = o or {}
  assert(o.resolver, "missing 'resolver'")
  assert(o.netconf, "missing 'netconf'")
  o.nsfile = o.nsfile or "resolved-subjects.tmp"
  self.__index = self
  setmetatable(o, self)
  return o
end

-- main entry for subjects to resolve
function _M:resolve(writer, subjects)
  writer:write(CSV.row("iface", "src hwaddr", "src ip", "nexthop hwaddr",
      "nexthop ip", "dst ip", "name"))
  for name, dstip in self:ns_resolve(subjects) do
    local iface, src_hwaddr, srcip, nexthop_ip = self:src_map(dstip)
    local nexthop_hwaddr
    if nexthop_ip then
      nexthop_hwaddr = self:nexthop_map(iface, nexthop_ip)
      if nexthop_hwaddr then
        writer:write(CSV.row(iface, src_hwaddr, srcip, nexthop_hwaddr,
          nexthop_ip, dstip, name))
      else
        self:nexthop_resolve(writer, iface, src_hwaddr, srcip, nexthop_ip,
          dstip, name)
      end
    end
  end
  self:nexthop_flush(writer)
end

function _M:nexthop_map(iface, nexthop_ip)
  return self.netconf[iface].ip_neigh[nexthop_ip]
end

function _M:nexthop_flush(writer)
  -- TODO: Implement (resolve nexthop_buffer)
  if self.nexthop_buffer then
    for i = 1, #self.nexthop_buffer do
      writer:write(CSV.row(table.unpack(self.nexthop_buffer[i])))
    end
  end
end

function _M:nexthop_resolve(writer, iface, src_hwaddr, srcip, nexthop_ip,
    dstip, name)
  self.nexthop_buffer = self.nexthop_buffer or {}
  local el = {iface, src_hwaddr, src_ip, "", nexthop_ip, dstip, name}
  table.insert(self.nexthop_buffer, el)
  if #self.nexthop_buffer == NEXTHOP_BUFSZ then
    self:nexthop_flush(writer)
  end
end

-- returns: iface, src_hwaddr, srcip, nexthop_ip
function _M:src_map(dstip)
  -- check if we have a destination IP address
  if not dstip then return end

  -- check if any of the interfaces has a direct route to this host
  for iface, cfg in pairs(self.netconf) do
    for _, src in ipairs(cfg.ip_srcs) do
      if src.subnet:contains(dstip) then
        return iface, cfg.ethaddr, tostring(src.addr), dstip
      end
    end
  end

  -- check if any of the interfaces has a gateway serving this host
  -- TODO: Maybe sort ip_gws by ascending number of addresses in subnet
  --       to avoid default gateway precedence?
  for iface, cfg in pairs(self.netconf) do
    local gw_addr
    for _, gw in ipairs(cfg.ip_gws) do
      if gw.subnet:contains(dstip) then
        gw_addr = gw.addr
        break
      end
    end
    if gw_addr then
      -- this iface has a gateway configured for this dstip, find a suitable
      -- srcip (XXX: only checks by protocol version)
      local dstver = yans.ip.addr(dstip):version()
      for _, src in ipairs(cfg.ip_srcs) do
        if src.addr:version() == dstver then
          return iface, cfg.ethaddr, tostring(src.addr), tostring(gw_addr)
        end
      end
    end
  end
end

-- takes a table of yans.ip.addrs and returns an iterator of address strings
local function addr_iter(addrs)
  local i = 1
  if not addrs or not addrs[i] then return end
  local nexter = addrs[i]:next()
  return function()
    local addr = nexter()
    if not addr then
      i = i + 1
      if not addrs[i] then return end
      nexter = addrs[i]:next()
      addr = nexter()
    end
    if addr then addr = tostring(addr) end
    return "", addr
  end
end

-- takes a table of (name, dstip) iterators and returns a union iterator
-- TODO: this would probably look nicer using coroutines
local function dstiter(iters)
  local i = 1
  return function()
    local name, dstip = iters[i]()
    if not name then
      i = i + 1
      if not iters[i] then return end
      name, dstip = iters[i]()
    end
    return name, dstip
  end
end

function _M:ns_resolve(subjects)
  if type(subjects) == "table" then
    subjects = table.concat(subjects, " ")
  end
  assert(type(subjects) == "string", "expected string for field 'subjects'")

  -- Split 'subjects' into 'addrs' and 'names' based on what they represent
  local addrs, names = {}, {}
  for subject in string.gmatch(subjects, "%S+") do
    local is_addrs, paddrs = pcall(yans.ip.addrs, subject)
    if is_addrs then
      table.insert(addrs, paddrs)
    else
      local name = yans.util.punycode_encode(subject)
      table.insert(names, name)
    end
  end

  -- resolve 'names' using the domain name resolver, to a temporary file
  self.resolver:resolve(self.nsfile, names)

  return dstiter{
    self.resolver:entries(self.nsfile),
    addr_iter(addrs)
  }
end

-- TODO: return an iterator for subjects
function _M:entries(reader)
  return function()
    return nil
  end
end

return _M
