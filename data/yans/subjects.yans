--[[

The goal of this code is to take a string consisting of whitespace
separated IPv[46] ranges (where a single address is also considered to be a
range) or domain name(s) and map to a
(iface,src-hwaddr,srcip,nexthop-hwaddr,nexthop-ip,dstip,name)-tuple. In
doing so, zero or more network actions may be performed.

The first part of this procedure, ns_resolve, is to map domain name(s) to IP
address(es). ns_resolve also punycodes name(s). After this step, we have a
sequence of (dstip,name)-tuples, where 'name' can be nil.

Next up we have src_map, which maps the iface, src-hwaddr and srcip to use
for the dstip.

After that we have nexthop_map, which tries to map the next hop.

For unknown next hops in nexthop_map, we have nexthop_resolve which tries to
resolve the next hop, and also updates. nexthop_resolve lookups are batched and
needs to be flushed at the end.

             (netconf, subjects)
                    |
                    v
               +----------+
               |ns_resolve|
               +----------+
                    |
                    |  (netconf, dstip,name)
                    v
                +-------+
                |src_map|
                +-------+
                    |
                    |  (netconf, iface, src-hwaddr, srcip, dstip, name)
                    v
              +-----------+       +---------------+
              |nexthop_map|------>|nexthop_resolve|
              +-----------+       +---------------+
                    |                     |
                    +----------+----------+
                               |
                               v
   (netconf, iface, src-hwaddr, srcip, nexthop-hwaddr, nexthop-ip, dstip, name)
]]--
--[[
function rp(node, depth)
  depth = depth or 0
  if type(node) == "table" then
    for k,v in pairs(node) do
      print(string.format("%s%s", string.rep("\t", depth), k))
      rp(v, depth + 1)
    end
  else
    print(string.format("%s%s", string.rep("\t", depth), node))
  end
end

netconf = require"svcs.netconf":new{...}:get_netconf()
rp(netconf)

em0
        ethaddr
                5c:ff:35:03:08:07
        ip_gws
                1
                        addr
                                155.4.38.81
                        subnet
                                0.0.0.0-255.255.255.255
        ip_srcs
                1
                        addr
                                fe80::5eff:35ff:fe03:807%em0
                        subnet
                                fe80::%em0-fe80::ffff:ffff:ffff:ffff%em0
                2
                        addr
                                155.4.38.87
                        subnet
                                155.4.38.80-155.4.38.95
        ip_neigh
                155.4.38.81
                        f8:98:ef:a3:68:df
        ip_dsts
                1
                        155.4.38.87
                2
                        155.4.38.80-155.4.38.95
                3
                        fe80::5eff:35ff:fe03:807%em0
                4
                        fe80::%em0-fe80::ffff:ffff:ffff:ffff%em0


]]--

CSV = require"csv"


_M = {}

function _M:new(o)
  o = o or {}
  assert(o.resolver, "missing 'resolver'")
  assert(o.netconf, "missing 'netconf'")
  o.nsfile = o.nsfile or "resolved-subjects.tmp"
  self.__index = self
  setmetatable(o, self)
  return o
end

-- main entry for subjects to resolve
function _M:resolve(writer, subjects)
  writer:write(CSV.row("iface", "src hwaddr", "src ip", "dst ip", "name"))
  for name, dstip in self:ns_resolve(subjects) do
    local iface, src_hwaddr, srcip = self:src_map(dstip, name)
    writer:write(CSV.row(
        iface      or "",
        src_hwaddr or "",
        srcip      or "",
        dstip      or "",
        name       or ""))
  end

--    local nexthop_hwaddr, nexthop_ip = self:nexhop_map(iface, src_hwaddr, srcip, dstip, name)
--    if not nexthop_hwaddr then
--      self:nexthop_resolve(iface, src_hwaddr, srcip, dstip, name)
--    else
--      self:output(writer, iface, src_hwaddr, srcip, nexthop_hwaddr, nexthop_ip, dstip, name)
--    end
--  end
--  self:flush_resolve(writer)
end

function _M:src_map(dstip, name)
  return nil, nil, nil
end

-- takes a table of yans.ip.addrs and returns an iterator of address strings
local function addr_iter(addrs)
  local i = 1
  if not addrs or not addrs[i] then return end
  local nexter = addrs[i]:next()
  return function()
    local addr = nexter()
    if not addr then
      i = i + 1
      if not addrs[i] then return end
      nexter = addrs[i]:next()
      addr = nexter()
    end
    if addr then addr = tostring(addr) end
    return "", addr
  end
end

-- takes a table of (name, dstip) iterators and returns a union iterator
-- TODO: this would probably look nicer using coroutines
local function dstiter(iters)
  local i = 1
  return function()
    local name, dstip = iters[i]()
    if not name then
      i = i + 1
      if not iters[i] then return end
      name, dstip = iters[i]()
    end
    return name, dstip
  end
end

function _M:ns_resolve(subjects)
  if type(subjects) == "table" then
    subjects = table.concat(subjects, " ")
  end
  assert(type(subjects) == "string", "expected string for field 'subjects'")

  -- Split 'subjects' into 'addrs' and 'names' based on what they represent
  local addrs, names = {}, {}
  for subject in string.gmatch(subjects, "%S+") do
    local is_addrs, paddrs = pcall(yans.ip.addrs, subject)
    if is_addrs then
      table.insert(addrs, paddrs)
    else
      local name = yans.util.punycode_encode(subject)
      table.insert(names, name)
    end
  end

  -- resolve 'names' using the domain name resolver, to a temporary file
  self.resolver:resolve(self.nsfile, names)

  return dstiter{
    self.resolver:entries(self.nsfile),
    addr_iter(addrs)
  }
end

-- TODO: return an iterator for subjects
function _M:entries(reader)
  return function()
    return nil
  end
end

return _M
