local _M = {

}

function _M:new(o)
  assert(o.path, "missing path")
  assert(o.opener, "missing opener")
  assert(o.msgbuf, "missing msgbuf")
  o.sock = yans.ycl.connect(o.path)
  self.__index = self
  setmetatable(o, self)
  return o
end

function _M:resolve(dstfile, hosts)
  -- validate parameters
  assert(type(dstfile) == "string", "missing or invalid dstfile")
  if type(hosts) == "table" then
    hosts = table.concat(hosts, " ")
  elseif type(hosts) ~= "string" then
    error("missing or invalid hosts")
  end

  -- open the destination file for writing and send it
  local file = yans.file
  local dstfd = self.opener:open(dstfile, "wb")
  self.sock:sendfd(dstfd)

  -- create the resolver request
  self.msgbuf:create_resolver_req{hosts = hosts}

  -- send the resolver request
  self.sock:sendmsg(self.msgbuf)

  -- receive the fd which signals done
  local closefd = self.sock:recvfd()

  -- wait for completion
  closefd:wait()
  closefd:close()
end

function _M:get_result_stream(srcfile)
  return self.opener:open(srcfile, "rb"):to_stream("zlib:rb")
end

function _M:entries(srcfile)
  local stream = self:get_result_stream(srcfile)
  return function() 
    local line = stream:read("l")
    if not line then return end
    local name, addr = string.match(line, "(%S+)%s*(%S*)")
    if #addr == 0 then addr = nil end
    return name, addr
  end
end

return _M
