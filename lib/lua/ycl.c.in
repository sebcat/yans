#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>

#include <lib/util/zfile.h>
#include <lib/ycl/ycl.h>
#include <lib/ycl/ycl_msg.h>
#include <lib/lua/ycl.h>

#define MTNAME_YCLMSG "yans.YCLMsg"
#define MTNAME_YCLCTX "yans.YCLCtx"
#define MTNAME_YCLFD  "yans.YCLFd"

#define checkmsg(L, i) \
  ((struct ycl_msg *)luaL_checkudata(L, (i), MTNAME_YCLMSG))

#define checkctx(L, i) \
  ((struct ycl_ctx *)luaL_checkudata(L, (i), MTNAME_YCLCTX))

#define checkyclfd(L, i) \
  ((struct l_fd *)luaL_checkudata(L, (i), MTNAME_YCLFD))

struct l_fd {
  int fd;
};

static int l_yclmsggc(lua_State *L) {
  struct ycl_msg *msg;

  msg = checkmsg(L, 1);
  ycl_msg_cleanup(msg);
  return 0;
}

static int l_yclmsg(lua_State *L) {
  struct ycl_msg *msg;

  msg = lua_newuserdata(L, sizeof(struct ycl_msg));
  ycl_msg_init(msg);
  luaL_setmetatable(L, MTNAME_YCLMSG);
  return 1;
}

static int l_yclmsgset(lua_State *L) {
  int ret;
  struct ycl_msg *msg;
  const char *str;
  size_t len = 0;

  msg = checkmsg(L, 1);
  str = luaL_checklstring(L, 2, &len);
  ret = ycl_msg_set(msg, str, len);
  if (ret != YCL_OK) {
    return luaL_error(L, "failed to set msg");
  }
  return 0;
}

static int l_yclmsgsize(lua_State *L) {
  struct ycl_msg *msg;

  msg = checkmsg(L, 1);
  lua_pushinteger(L, (lua_Integer)msg->buf.len);
  return 1;
}

static int l_yclmsgdata(lua_State *L) {
  struct ycl_msg *msg;

  msg = checkmsg(L, 1);
  lua_pushlstring(L, msg->buf.data, msg->buf.len);
  return 1;
}

//@@YCLIMPL@@

static int l_mkyclfd(lua_State *L, int fd) {
  struct l_fd *lfd;
  lfd = lua_newuserdata(L, sizeof(struct l_fd));
  lfd->fd = fd;
  luaL_setmetatable(L, MTNAME_YCLFD);
  return 1;
}

static int l_yclfd(lua_State *L) {
  int fd;

  fd = (int)luaL_checkinteger(L, 1);
  l_mkyclfd(L, fd);
  return 1;
}

static int l_fdclose(lua_State *L) {
  struct l_fd *lfd;
  lfd = checkyclfd(L, 1);
  if (lfd->fd >= 0) {
    close(lfd->fd);
    lfd->fd = -1;
  }
  return 0;
}

static int l_fdget(lua_State *L) {
  struct l_fd *lfd;
  lfd = checkyclfd(L, 1);
  lua_pushinteger(L, (lua_Integer)lfd->fd);
  return 1;
}

static int l_fdwait(lua_State *L) {
  struct pollfd pfd;
  struct l_fd *lfd;
  int ret;

  lfd = checkyclfd(L, 1);
  pfd.fd = lfd->fd;
  pfd.events = POLLIN | POLLERR;
  do {
    ret = poll(&pfd, 1, INFTIM);
  } while (ret < 0 && errno == EINTR);

  if (ret < 0) {
    return luaL_error(L, "poll: %s", strerror(errno));
  }

  return 0;
}

static int l_streamclose(lua_State *L) {
  luaL_Stream *s;

  s = (luaL_Stream*)luaL_checkudata(L, 1, LUA_FILEHANDLE);
  if (s->f) {
    fclose(s->f);
  }
  s->f = NULL;
  return 0;
}

static int l_fdtostream(lua_State *L) {
  struct l_fd *lfd;
  luaL_Stream *s;
  const char *mode;
  FILE *fp;

  lfd = checkyclfd(L, 1);
  mode = luaL_checkstring(L, 2);

  if (lfd->fd < 0) {
    return luaL_error(L, "to_stream called on closed fd");
  }

  if (strncmp(mode, "zlib:", 5) == 0) {
    fp = zfile_fdopen(lfd->fd, mode + 5);
  } else {
    fp = fdopen(lfd->fd, mode);
  }

  if (fp == NULL) {
    return luaL_error(L, "to_stream: %s",
        (errno == 0) ? "unknown error" : strerror(errno));
  }

  s = lua_newuserdata(L, sizeof(luaL_Stream));
  luaL_setmetatable(L, LUA_FILEHANDLE);
  s->f = fp;
  s->closef = &l_streamclose;
  lfd->fd = -1; /* to avoid double-close, the stream object now owns the fd */
  return 1;
}

static int l_yclctx(lua_State *L) {
  struct ycl_ctx *ctx;
  int fd;

  fd = (int)luaL_checkinteger(L, 1);
  if (fd < 0) {
    return luaL_error(L, "invalid file descriptor");
  }

  ctx = lua_newuserdata(L, sizeof(struct ycl_ctx));
  luaL_setmetatable(L, MTNAME_YCLCTX);
  ycl_init(ctx, fd);

  /* for the eds use case, the file descriptor is managed externally and
   * closed implicitly by eds. If ycl closes its fd on gc, that may occur
   * after a new client connects, receiving the same fd number. So if we
   * create a ycl_ctx with an externally opened file descriptor, the fd should
   * be closed externally too. Again, for our current use case. */
  ycl_set_externalfd(ctx);
  return 1;
}

static int l_yclconnect(lua_State *L) {
  struct ycl_ctx *ctx;
  const char *dst;

  dst = luaL_checkstring(L, 1);
  ctx = lua_newuserdata(L, sizeof(struct ycl_ctx));
  luaL_setmetatable(L, MTNAME_YCLCTX);
  if (ycl_connect(ctx, dst) != YCL_OK) {
    return luaL_error(L, "%s", ycl_strerror(ctx));
  }

  return 1;
}

static int l_ctxgc(lua_State *L) {
  struct ycl_ctx *ctx;

  ctx = checkctx(L, 1);
  ycl_close(ctx);
  return 0;
}

static int l_ctxsetnonblock(lua_State *L) {
  struct ycl_ctx *ctx;
  int status;

  ctx = checkctx(L, 1);
  status = luaL_checkinteger(L, 2);
  if (ycl_setnonblock(ctx, status) != YCL_OK) {
    return luaL_error(L, "%s", ycl_strerror(ctx));
  }
  return 0;
}

static int l_ctxsendmsg(lua_State *L) {
  struct ycl_ctx *ctx;
  struct ycl_msg *msg;
  int ret;

  ctx = checkctx(L, 1);
  msg = checkmsg(L, 2);
  ret = ycl_sendmsg(ctx, msg);
  if (ret == YCL_ERR) {
    return luaL_error(L, "%s", ycl_strerror(ctx));
  }

  lua_pushinteger(L, (lua_Integer)ret);
  return 1;
}

static int l_ctxrecvmsg(lua_State *L) {
  struct ycl_ctx *ctx;
  struct ycl_msg *msg;
  int ret;

  ctx = checkctx(L, 1);
  msg = checkmsg(L, 2);
  ret = ycl_recvmsg(ctx, msg);
  if (ret == YCL_ERR) {
    return luaL_error(L, "%s", ycl_strerror(ctx));
  }

  lua_pushinteger(L, (lua_Integer)ret);
  return 1;
}

static int l_ctxsendfd(lua_State *L) {
  struct ycl_ctx *ctx;
  struct l_fd *lfd;
  int ret;

  ctx = checkctx(L, 1);
  lfd = checkyclfd(L, 2);
  ret = ycl_sendfd(ctx, lfd->fd, 0);
  if (ret == YCL_ERR) {
    return luaL_error(L, "%s", ycl_strerror(ctx));
  }

  lua_pushinteger(L, (lua_Integer)ret);
  return 1;
}

static int l_ctxrecvfd(lua_State *L) {
  struct ycl_ctx *ctx;
  int ret;
  int fd = -1;

  ctx = checkctx(L, 1);
  ret = ycl_recvfd(ctx, &fd);
  if (ret == YCL_ERR) {
    return luaL_error(L, "%s", ycl_strerror(ctx));
  } else if (ret == YCL_AGAIN) {
    lua_pushnil(L);
  } else {
    l_mkyclfd(L, fd);
  }
  lua_pushinteger(L, (lua_Integer)ret);
  return 2;
}


static const struct luaL_Reg yclmsg_m[] = {
  {"__gc", l_yclmsggc},
  {"set", l_yclmsgset},
  {"size", l_yclmsgsize},
  {"data", l_yclmsgdata},
//@@YCLTBL@@
  {NULL, NULL},
};

static const struct luaL_Reg yclctx_m[] = {
  {"__gc", l_ctxgc},
  {"setnonblock", l_ctxsetnonblock},
  {"sendmsg", l_ctxsendmsg},
  {"recvmsg", l_ctxrecvmsg},
  {"sendfd", l_ctxsendfd},
  {"recvfd", l_ctxrecvfd},
  {NULL, NULL},
};

static const struct luaL_Reg yclfd_m[] = {
  {"__gc", l_fdclose},
  {"close", l_fdclose},
  {"get", l_fdget},
  {"wait", l_fdwait},
  {"to_stream", l_fdtostream},
  {NULL, NULL},
};

static const struct luaL_Reg ycl_f[] = {
  {"ctx", l_yclctx},
  {"connect", l_yclconnect},
  {"msg", l_yclmsg},
  {"fd", l_yclfd},
  {NULL, NULL},
};

int luaopen_ycl(lua_State *L) {
  size_t i;
  struct {
    const char *name;
    const struct luaL_Reg *reg;
  } mts[] = {
    {MTNAME_YCLCTX, yclctx_m},
    {MTNAME_YCLMSG, yclmsg_m},
    {MTNAME_YCLFD, yclfd_m},
    {NULL, NULL},
  };
  struct {
    const char *name;
    lua_Integer val;
  } consts[] = {
    {"AGAIN", YCL_AGAIN},
    {"ERROR", YCL_ERR},
    {"OK", YCL_OK},
    {"O_APPEND", O_APPEND},
    {"O_CREAT", O_CREAT},
    {"O_EXCL", O_EXCL},
    {"O_NOCTTY", O_NOCTTY},
    {"O_NONBLOCK", O_NONBLOCK},
    {"O_RDONLY", O_RDONLY},
    {"O_RDWR", O_RDWR},
    {"O_SYNC", O_SYNC},
    {"O_TRUNC", O_TRUNC},
    {"O_WRONLY", O_WRONLY},
    {NULL, 0},
  };

  for (i = 0; mts[i].name != NULL; i++) {
    luaL_newmetatable(L, mts[i].name);
    lua_pushvalue(L, -1);
    lua_setfield(L, -2, "__index");
    luaL_setfuncs(L, mts[i].reg, 0);
  }

  luaL_newlib(L, ycl_f);

  for (i = 0; consts[i].name != NULL; i++) {
    lua_pushinteger(L, consts[i].val);
    lua_setfield(L, -2, consts[i].name);
  }

  return 1;
}
