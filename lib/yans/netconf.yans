
local _M = {

}

local function from_routes(routes)
  -- get local references for 'routes' members
  local ifaces = routes.ifaces
  local ip_srcs = routes.ip_srcs
  local ip_neigh = routes.ip_neigh
  local ip4_routes = routes.ip4_routes
  local ip6_routes = routes.ip6_routes

  -- setup temporary tables
  local ifnames  = {}
  local ethaddrs = {}
  local hwbyname = {}
  local ipsrcs   = {}
  local ipdsts   = {}
  local ipgws    = {}
  local ipneigh  = {}

  -- determine suitable interfaces
  for k,v in pairs(ifaces) do
    if v.up and not v.loopback then
      hwbyname[v.name]  = v.addr
      ifnames[v.index]  = v.name
      ethaddrs[v.index] = v.addr
      ipsrcs[v.name]    = {}
      ipdsts[v.index]   = {}
      ipgws[v.index]    = {}
      ipneigh[v.name]   = {}
    end
  end

  -- get IP source addresses for suitable interfaces
  for _, v in pairs(ip_srcs) do
    local ifname = v[1]
    if ipsrcs[ifname] then
      table.insert(ipsrcs[ifname], {addr=v[2], subnet=v[3]})
    end
  end

  -- determine IPv4 addresses routed to the local network, and gateways
  for _, v in pairs(ip4_routes) do
    if ifnames[v.gw_ifindex] and v.gw_ifindex == v.ifindex then
      table.insert(ipdsts[v.gw_ifindex], v.block)
    elseif ifnames[v.ifindex] and v.gw then
      table.insert(ipgws[v.ifindex], {addr=v.gw, subnet=v.block})
    end
  end

  -- determine IPv6 addresses routed to the local network, and gateways
  for _, v in pairs(ip6_routes) do
    if ifnames[v.gw_ifindex] and v.gw_ifindex == v.ifindex then
      table.insert(ipdsts[v.gw_ifindex], v.block)
    elseif ifnames[v.ifindex] and v.gw then
      table.insert(ipgws[v.ifindex], {addr=v.gw, subnet=v.block})
    end
  end

  -- determine what IPv6 neighbors we have for our set of ifaces, if any
  if ip_neigh then
    for _, v in pairs(ip_neigh) do
      local hwaddr = v.hwaddr
      if ipsrcs[v.iface] and hwbyname[v.iface] ~= hwaddr then
        ipneigh[v.iface][tostring(v.ipaddr)] = hwaddr
      end
    end
  end

  -- format response
  local resp = {}
  for index, name in pairs(ifnames) do
    local ip_srcs = ipsrcs[name]
    if #ip_srcs > 0 then
      resp[name] = {
        ethaddr  = ethaddrs[index],
        ip_srcs  = ip_srcs,
        ip_dsts  = ipdsts[index],
        ip_gws   = ipgws[index],
        ip_neigh = ipneigh[name],
      }
    end
  end
  return resp
end

function _M:new(o)
  o = from_routes(o or {})
  self.__index = self
  setmetatable(o, self)
  return o
end

function _M:_print(val,indent)
  if type(val) ~= "table" then
    print(string.format("%s%s (%s)", string.rep(" ", indent), tostring(val),
        type(val)))
  else
    for k,v in pairs(val) do
      print(string.format("%s%s (%s)", string.rep(" ", indent), tostring(k),
           type(k)))
      self:_print(v, indent+2)
    end
  end
end

function _M:print()
  self:_print(self, 0)
end

return _M
