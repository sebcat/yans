
local _M = {
  SVC_NETCONF = "./lel/netconf.sock",
  SVC_ETHFRAME = "./lel/ethframe.sock",
  SVC_PCAP = "./lel/pcap.sock",
  SVC_STORE = "./lel/stored.sock",
  PPS = 300,
}

local Netconf = require"svcs.netconf"

function _M:new(o)
  o = o or {}
  local ycl = yans.ycl
  o.netconf = Netconf:new{path = self.SVC_NETCONF}
  o.ethframe_sock = ycl.connect(self.SVC_ETHFRAME)
  o.store_sock = ycl.connect(self.SVC_STORE)
  o.pcap_sock = ycl.connect(self.SVC_PCAP)
  o.msgbuf = ycl.msg()
  setmetatable(o, self)
  self.__index = self
  return o
end

function _M:get_netconf()
  return self.netconf:get_netconf()
end

function _M:store_enter(store_id)
  assert(not self.store_id, "attempted entering store more than once")
  self.msgbuf:create_store_enter{
    store_id = store_id,
  }
  self.store_sock:sendmsg(self.msgbuf)
  self.store_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
  store_id = resp.okmsg
  assert(store_id and #store_id > 0, "invalid store ID from service")
  self.store_id = store_id
  return store_id
end

function _M:store_open(path, flags)
  assert(self.store_id, "store_open without preceding store_enter")
  self.msgbuf:create_store_open{
    path = path,
    flags = flags,
  }
  self.store_sock:sendmsg(self.msgbuf)
  return self.store_sock:recvfd()
end

function _M:pcap_start(fd, iface, filter)
  self.msgbuf:create_pcap_req{
    iface = iface,
    filter = filter,
  }
  self.pcap_sock:sendfd(fd)
  self.pcap_sock:sendmsg(self.msgbuf)
  self.pcap_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
  fd:close()
end

function _M:pcap_stop()
  self.msgbuf:create_pcap_close{}
  self.pcap_sock:sendmsg(self.msgbuf)
  self.pcap_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
end

function _M:send_packets(opts)
  opts.pps = opts.pps or self.PPS
  self.msgbuf:create_ethframe_req(opts)
  self.ethframe_sock:sendmsg(self.msgbuf)
  self.ethframe_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
end

return _M
