local PacketReader = require"ethframe.reader"
local PacketDecoder = require"ethframe.decoder"
local Netconf = require"netconf"
local global_filter = [[

  (arp[6:2] = 2) or
  (src net 10.0.0.0/8) or
  (src net 172.16.0.0/12) or
  (src net 192.168.0.0/16) or
  (src net 100.64.0.0/10) or
  (src net 169.254.0.0/16) or
  (src net fc00:0000:0000:0000:0000:0000:0000:0000/7) or
  (src net fe80:0000:0000:0000:0000:0000:0000:0000/10) or
  (src net fec0:0000:0000:0000:0000:0000:0000:0000/10)]]

local _M = {
  nonet = false,    -- no sending or receiving of data
  store = nil,      -- if non-nil, the store ID to use
  passive = false,  -- no sending of packets
  linger = 3,       -- number of seconds to wait for packets
}

function _M:new(o)
  o = o or {}
  self.__index = self
  setmetatable(o, self)
  return o
end

function _M:run(scanner)
  -- setup the store
  local store_id = scanner:store_enter(self.store)
  print("STORE   ", store_id)
  print("---")

  -- get the network configuration
  local netconf = scanner:get_netconf()
  netconf:print()

  local ifaces
  if not self.nonet then
    ifaces = self:send_recv_packets(scanner, netconf)
  end

  -- Aggregate result from captured frames. Avoid keeping too much data in
  -- memory at the same time. We use tables for deduplication, and we keep
  -- the output format simple. Since interfaces, IP and Ethernet addresses are
  -- of a specific character set, and lines are easy to parse, we use CSV.
  -- However, care should be taken to be absolutely sure that the data does
  -- not contain any delimiters, because escaping in CSV is a PITA across
  -- different parsers. We may want to consider other formats for that.
  local file = yans.file
  local reswriter = scanner:store_open("lldisco-result.csv.gz",
      file.O_WRONLY | file.O_CREAT | file.O_TRUNC):to_stream("zlib:wb")

  if not ifaces then
    ifaces = self:get_ifaces()
  end

  for ifname in string.gmatch(ifaces, "%S+") do
    local dedup = {}
    local filename = string.format("lldisco-%s.pcap.gz", ifname)
    local stream = scanner:store_open(filename,
        file.O_RDONLY):to_stream("zlib:rb")
    local reader = PacketReader:open(stream)
    if reader then
      for sec, frac, data in reader:next() do
        local res = PacketDecoder:decode(data)
        if res then
          if res.arp_oper == 2 and
              res.arp_tha == res.eth_dst and
              res.arp_sha == res.eth_src then
            local dedupstr = string.format("%s_%s", res.arp_spa, res.eth_src)
            if not dedup[dedupstr] then
              reswriter:write(string.format("arp|%s|%s|%s\n", ifname,
                  res.arp_spa, res.eth_src))
              dedup[dedupstr] = true
            end
          elseif res.ip4_src then
            local dedupstr = string.format("%s_%s", res.ip4_src, res.eth_src)
            if not dedup[dedupstr] then
              reswriter:write(string.format("ip4|%s|%s|%s\n", ifname,
                  res.ip4_src, res.eth_src))
              dedup[dedupstr] = true
            end
          elseif res.ip6_src then
            local dedupstr = string.format("%s_%s", res.ip6_src, res.eth_src)
            if not dedup[dedupstr] then
              reswriter:write(string.format("ip6|%s|%s|%s\n", ifname,
                  res.ip6_src, res.eth_src))
              dedup[dedupstr] = true
            end
          end
        end -- TODO: log unknown response packet?
      end
    end
    stream:close()
  end
  reswriter:close()
end

function _M:store_ifaces(scanner, ifaces)
  local file = yans.file
  local data = string.format("%s\n", ifaces)
  local stream = scanner:store_open("lldisco-ifaces.txt",
      file.O_CREAT | file.O_WRONLY | file.O_TRUNC):to_stream("wb")
  stream:write(data)
  stream:close()
end

function _M:get_ifaces(scanner)
  local stream = scanner:store_open("lldisco-ifaces.txt",
      yans.file.O_RDONLY):to_stream("rb")
  local ifaces = stream:read("a")
  stream:close()
  return ifaces
end

function _M:send_packets(scanner, ifname, ifconf)
  local ip4_srcs, ip6_srcs, ip4_dsts = {}, {}, {}
  local ifaddr = ifconf.ethaddr

  -- split source addresses by IP version
  for _, ip_src in pairs(ifconf.ip_srcs) do
    local addr = ip_src.addr
    local v = addr:version()
    if v == 4 then
      table.insert(ip4_srcs, addr)
    elseif v == 6 then
      table.insert(ip6_srcs, addr)
    end
  end

  -- build a table of strings of all the IPv4 destination addresses, if any
  for _,blk in pairs(ifconf.ip_dsts) do
    if blk:version() == 4 then
      table.insert(ip4_dsts, tostring(blk))
    end
  end

  for _, ip4_src in pairs(ip4_srcs) do
    scanner:send_packets{
      iface = ifname,
      categories = "arp-req|ll-disco",
      eth_src = ifaddr,
      ip_src = tostring(ip4_src),
      ip_dsts = table.concat(ip4_dsts, " "),
    }
  end

  for _, ip6_src in pairs(ip6_srcs) do
    scanner:send_packets{
      iface = ifname,
      categories = "ll-disco",
      eth_src = ifaddr,
      ip_src = tostring(ip6_src),
    }
  end
end

function _M:send_recv_packets(scanner, netconf)
  local file = yans.file
  local util = yans.util
  local ifaces = {}
  for ifname, entry in pairs(netconf) do
    -- setup the capture for this interface
    local ifaddr = entry.ethaddr
    local fmt = "(not ether src %s) and (%s)"
    local filter = string.format(fmt, ifaddr, global_filter)
    local filename = string.format("lldisco-%s.pcap.gz", ifname)
    local fd = scanner:store_open(filename,
        file.O_CREAT | file.O_WRONLY | file.O_TRUNC)
    print(string.format("%s: %s", filename, filter))
    scanner:pcap_start(fd, ifname, filter) -- pcap_start closes fd
    util.nanosleep(0, 500000000) -- wait a bit to establish the capture

    if not self.passive then
      self:send_packets(scanner, ifname, entry)
    end

    util.nanosleep(self.linger, 0) -- wait a bit for incoming frames
    scanner:pcap_stop()
    table.insert(ifaces, ifname)
  end
  ifaces = table.concat(ifaces, " ")
  self:store_ifaces(scanner, ifaces)
  return ifaces
end

return _M
