/* auto-generated by yclgen - DO NOT EDIT */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <lib/util/netstring.h>
#include <lib/ycl/ycl_msg.h>

#pragma GCC visibility push(default)
static long s2l(const char *s) {
  long res = 0;
  char ch;

  while ((ch = *s) >= '0' && ch <= '7') {
    res = res << 3;
    res += ch - '0';
    s++;
  }

  return res;
}

static char *l2s(char *s, size_t len, long l) {
  while (len > 0) {
    len--;
    s[len] = '0' + (l & 0x07);
    l = l >> 3;
    if (l == 0) {
      break;
    }
  }

  return s + len;
}

static int load_datas(buf_t *b, char *curr, size_t len,
    size_t *outoffset, size_t *nelems) {
  int ret;
  char *elem;
  size_t elemlen;
  size_t offset;
  size_t count;
  struct ycl_data tmp;

  ret = buf_align(b);
  if (ret < 0) {
    return YCL_ERR;
  }

  offset = b->len;
  count = 0;
  while (len > 0) {
    ret = netstring_next(&elem, &elemlen, &curr, &len);
    if (ret != NETSTRING_OK) {
      return YCL_ERR;
    }
    tmp.data = elem;
    tmp.len = elemlen;
    ret = buf_adata(b, &tmp, sizeof(tmp));
    if (ret < 0) {
      return YCL_ERR;
    }
    count++;
  }

  *outoffset = offset;
  *nelems = count;
  return YCL_OK;
}

int ycl_msg_create_ethframe_req(struct ycl_msg *msg,
    struct ycl_msg_ethframe_req *r) {
  int ret;
  int status = YCL_ERR;

  if (ycl_msg_use_optbuf(msg) < 0) {
    goto done;
  }

  ycl_msg_reset(msg);
  if (r->pps != 0) {
    char numbuf[48];
    char *num;

    num = l2s(numbuf, sizeof(numbuf), r->pps);
    ret = netstring_append_pair(&msg->mbuf, "pps",
        sizeof("pps")-1, num, numbuf + sizeof(numbuf) - num);
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->iface != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "iface",
        sizeof("iface")-1, r->iface, strlen(r->iface));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->categories != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "categories",
        sizeof("categories")-1, r->categories, strlen(r->categories));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->eth_src != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "eth_src",
        sizeof("eth_src")-1, r->eth_src, strlen(r->eth_src));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->eth_dst != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "eth_dst",
        sizeof("eth_dst")-1, r->eth_dst, strlen(r->eth_dst));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->ip_src != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "ip_src",
        sizeof("ip_src")-1, r->ip_src, strlen(r->ip_src));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->ip_dsts != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "ip_dsts",
        sizeof("ip_dsts")-1, r->ip_dsts, strlen(r->ip_dsts));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->port_dsts != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "port_dsts",
        sizeof("port_dsts")-1, r->port_dsts, strlen(r->port_dsts));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->custom_frames != NULL && r->ncustom_frames > 0) {
    struct ycl_data *ptr;
    size_t i;
    size_t nelems;

    ptr = r->custom_frames;
    nelems = r->ncustom_frames;
    buf_clear(&msg->optbuf);
    for (i = 0; i < nelems; i++) {
      ret = netstring_append_buf(&msg->optbuf, ptr[i].data,
          ptr[i].len);
      if (ret != NETSTRING_OK) {
        goto done;
      }
    }
    ret = netstring_append_pair(&msg->mbuf, "custom_frames",
        sizeof("custom_frames")-1, msg->optbuf.data, msg->optbuf.len);
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  ret = netstring_append_buf(&msg->buf, msg->mbuf.data, msg->mbuf.len);
  if (ret != NETSTRING_OK) {
    goto done;
  }

  status = YCL_OK;
done:
  return status;
}

int ycl_msg_parse_ethframe_req(struct ycl_msg *msg,
    struct ycl_msg_ethframe_req *r) {
  struct netstring_pair pair;
  int result = YCL_ERR;
  char *curr;
  size_t len;
  int ret;
  size_t pairoff;
  size_t currpair;
  static const char *names[] = {
      "pps",
      "iface",
      "categories",
      "eth_src",
      "eth_dst",
      "ip_src",
      "ip_dsts",
      "port_dsts",
      "custom_frames",
  };

  memset(r, 0, sizeof(*r));
  buf_clear(&msg->mbuf);
  ret = netstring_parse(&curr, &len, msg->buf.data, msg->buf.len);
  if (ret != NETSTRING_OK) {
    goto done;
  }

  /* ycl_msg_create_* will create messages in a determinable order.
   * We use that order for our best case, and do a linear search for
   * our worst case. */
  for (pairoff = 0;
      netstring_next_pair(&pair, &curr, &len) == NETSTRING_OK;
      pairoff = (pairoff + 1) % (sizeof(names) / sizeof(char*))) {
    currpair = pairoff;
    do {
      if (strcmp(pair.key, names[currpair]) == 0) {
        switch(currpair) {
        case 0: /* pps */
          r->pps = s2l(pair.value);
          break;
        case 1: /* iface */
          r->iface = pair.value;
          break;
        case 2: /* categories */
          r->categories = pair.value;
          break;
        case 3: /* eth_src */
          r->eth_src = pair.value;
          break;
        case 4: /* eth_dst */
          r->eth_dst = pair.value;
          break;
        case 5: /* ip_src */
          r->ip_src = pair.value;
          break;
        case 6: /* ip_dsts */
          r->ip_dsts = pair.value;
          break;
        case 7: /* port_dsts */
          r->port_dsts = pair.value;
          break;
        case 8: /* custom_frames */
          ret = load_datas(&msg->mbuf, pair.value, pair.valuelen,
              (size_t*)&r->custom_frames, &r->ncustom_frames);
          if (ret != YCL_OK) {
            goto done;
          }
          break;
          default:
            abort(); /* XXX: Inconsistent state */
        }
        break;
      }
      currpair = (currpair + 1) % (sizeof(names) / sizeof(char*));
    } while (currpair != pairoff);
  }

  if (r->ncustom_frames > 0) {
    r->custom_frames = (void*)(msg->mbuf.data + (size_t)r->custom_frames);
  }

  result = YCL_OK;
done:
  return result;
}

int ycl_msg_create_pcap_close(struct ycl_msg *msg,
    struct ycl_msg_pcap_close *r) {
  int ret;
  ycl_msg_reset(msg);
  ret = buf_adata(&msg->buf, "0:,", 3);
  if (ret < 0) {
    return YCL_ERR;
  }
  return YCL_OK;
}

int ycl_msg_parse_pcap_close(struct ycl_msg *msg,
    struct ycl_msg_pcap_close *r) {
  memset(r, 0, sizeof(*r));
  return YCL_OK;
}

int ycl_msg_create_pcap_req(struct ycl_msg *msg,
    struct ycl_msg_pcap_req *r) {
  int ret;
  int status = YCL_ERR;

  ycl_msg_reset(msg);
  if (r->iface != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "iface",
        sizeof("iface")-1, r->iface, strlen(r->iface));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->filter != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "filter",
        sizeof("filter")-1, r->filter, strlen(r->filter));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  ret = netstring_append_buf(&msg->buf, msg->mbuf.data, msg->mbuf.len);
  if (ret != NETSTRING_OK) {
    goto done;
  }

  status = YCL_OK;
done:
  return status;
}

int ycl_msg_parse_pcap_req(struct ycl_msg *msg,
    struct ycl_msg_pcap_req *r) {
  struct netstring_pair pair;
  int result = YCL_ERR;
  char *curr;
  size_t len;
  int ret;
  size_t pairoff;
  size_t currpair;
  static const char *names[] = {
      "iface",
      "filter",
  };

  memset(r, 0, sizeof(*r));
  buf_clear(&msg->mbuf);
  ret = netstring_parse(&curr, &len, msg->buf.data, msg->buf.len);
  if (ret != NETSTRING_OK) {
    goto done;
  }

  /* ycl_msg_create_* will create messages in a determinable order.
   * We use that order for our best case, and do a linear search for
   * our worst case. */
  for (pairoff = 0;
      netstring_next_pair(&pair, &curr, &len) == NETSTRING_OK;
      pairoff = (pairoff + 1) % (sizeof(names) / sizeof(char*))) {
    currpair = pairoff;
    do {
      if (strcmp(pair.key, names[currpair]) == 0) {
        switch(currpair) {
        case 0: /* iface */
          r->iface = pair.value;
          break;
        case 1: /* filter */
          r->filter = pair.value;
          break;
          default:
            abort(); /* XXX: Inconsistent state */
        }
        break;
      }
      currpair = (currpair + 1) % (sizeof(names) / sizeof(char*));
    } while (currpair != pairoff);
  }


  result = YCL_OK;
done:
  return result;
}

int ycl_msg_create_status_resp(struct ycl_msg *msg,
    struct ycl_msg_status_resp *r) {
  int ret;
  int status = YCL_ERR;

  ycl_msg_reset(msg);
  if (r->okmsg != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "okmsg",
        sizeof("okmsg")-1, r->okmsg, strlen(r->okmsg));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  if (r->errmsg != NULL) {
    ret = netstring_append_pair(&msg->mbuf, "errmsg",
        sizeof("errmsg")-1, r->errmsg, strlen(r->errmsg));
    if (ret != NETSTRING_OK) {
      goto done;
    }
  }

  ret = netstring_append_buf(&msg->buf, msg->mbuf.data, msg->mbuf.len);
  if (ret != NETSTRING_OK) {
    goto done;
  }

  status = YCL_OK;
done:
  return status;
}

int ycl_msg_parse_status_resp(struct ycl_msg *msg,
    struct ycl_msg_status_resp *r) {
  struct netstring_pair pair;
  int result = YCL_ERR;
  char *curr;
  size_t len;
  int ret;
  size_t pairoff;
  size_t currpair;
  static const char *names[] = {
      "okmsg",
      "errmsg",
  };

  memset(r, 0, sizeof(*r));
  buf_clear(&msg->mbuf);
  ret = netstring_parse(&curr, &len, msg->buf.data, msg->buf.len);
  if (ret != NETSTRING_OK) {
    goto done;
  }

  /* ycl_msg_create_* will create messages in a determinable order.
   * We use that order for our best case, and do a linear search for
   * our worst case. */
  for (pairoff = 0;
      netstring_next_pair(&pair, &curr, &len) == NETSTRING_OK;
      pairoff = (pairoff + 1) % (sizeof(names) / sizeof(char*))) {
    currpair = pairoff;
    do {
      if (strcmp(pair.key, names[currpair]) == 0) {
        switch(currpair) {
        case 0: /* okmsg */
          r->okmsg = pair.value;
          break;
        case 1: /* errmsg */
          r->errmsg = pair.value;
          break;
          default:
            abort(); /* XXX: Inconsistent state */
        }
        break;
      }
      currpair = (currpair + 1) % (sizeof(names) / sizeof(char*));
    } while (currpair != pairoff);
  }


  result = YCL_OK;
done:
  return result;
}

#pragma GCC visibility pop
