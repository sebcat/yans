#!/usr/bin/env yans

local function netconf_from_routes(routes)
  -- get local references for 'routes' members
  local ifaces = routes.ifaces
  local ip4_routes = routes.ip4_routes
  local ip6_routes = routes.ip6_routes
  local ip4_srcs = routes.ip4_srcs
  local ip6_srcs = routes.ip6_srcs

  -- setup temporary tables
  local ifnames = {}
  local ethaddrs = {}
  local ip4srcs = {}
  local ip6srcs = {}
  local ip4dsts = {}

  -- determine suitable interfaces
  for k,v in pairs(ifaces) do
    if v.up and not v.loopback then
      ifnames[v.index] = v.name
      ethaddrs[v.index] = v.addr
      ip4srcs[v.name] = {}
      ip6srcs[v.name] = {}
      ip4dsts[v.index] = {}
    end
  end

  -- get IPv4 source addresses for suitable interfaces
  for k,v in pairs(ip4_srcs) do
    local ifname = v[1]
    if ip4srcs[ifname] then
      local srcaddr = v[2]
      table.insert(ip4srcs[ifname], tostring(srcaddr))
    end
  end

  -- get IPv6 source addresses for suitable interfaces
  for k,v in pairs(ip6_srcs) do
    local ifname = v[1]
    if ip6srcs[ifname] then
      local srcaddr = v[2]
      table.insert(ip6srcs[ifname], tostring(srcaddr))
    end
  end

  -- determine IPv4 addresses routed to the local network
  for k,v in pairs(ip4_routes) do
    if ifnames[v.gw_ifindex] and v.gw_ifindex == v.ifindex then
      table.insert(ip4dsts[v.gw_ifindex], tostring(v.block))
    end
  end

  -- format response
  local resp = {}
  for index, name in pairs(ifnames) do
    local entry = {}
    entry.ifname = name
    entry.ifaddr = tostring(ethaddrs[index])
    entry.ip4_srcs = ip4srcs[name]
    entry.ip6_srcs = ip6srcs[name]
    entry.ip4_dsts = ip4dsts[index]
    table.insert(resp, entry)
  end
  return resp
end

local PacketReader = {}

function PacketReader:open(stream)
  assert(stream, "missing stream parameter")
  --[[
  typedef struct pcap_hdr_s {
          uint32_t magic_number;
          uint16_t version_major;
          uint16_t version_minor;
          int32_t  thiszone;      /* timezone correction*/
          uint32_t sigfigs;       /* timestamp accuracy*/
          uint32_t snaplen;
          uint32_t network;       /* link type*/
  } pcap_hdr_t;
  sizeof(pcap_hdr_t) == 24
  magic:
    0xa1b2c3d4 native byte order, non-nanosec time resolution
    0xa1b23c4d native byte irder, nanosec time resolution
    0xd4c3b2a1 non-native byte order, non-nanosec time resolution
    0x4d3cb2a1 non-native byte order, nanosec time resolution
  network: 1 == ethernet. http://www.tcpdump.org/linktypes.html

  typedef struct pcaprec_hdr_s {
          guint32 ts_sec;        /* timestamp seconds */
          guint32 ts_usec;       /* timestamp microseconds */
          guint32 incl_len;      /* number of octets of packet saved in file */
          guint32 orig_len;      /* actual length of packet */
  } pcaprec_hdr_t;

  ]]--

  local hdr = stream:read(24)
  if not hdr or #hdr ~= 24 then
    return nil
  end

  local hdrfmt = "<I4" -- assume little endian to begin with
  local framefmt = ""
  local magic = string.unpack(hdrfmt, hdr)
  if magic == 0xa1b2c3d4 or magic == 0xa1b23c4d then
    hdrfmt = "<I4I2I2i4I4I4I4"
    framefmt = "<I4I4I4I4"
  elseif magic == 0xd4c3b2a1 or magic == 0x4d3cb2a1 then
    hdrfmt = ">I4I2I2i4I4I4I4"
    framefmt = ">I4I4I4I4"
  else
    error(string.format("unknown magic: 0x%08x", magic))
  end

  local o = {stream = stream, framefmt = framefmt}
  o.magic, o.major, o.minor, o.thiszone, o.sigfigs,
      o.snaplen, o.network = string.unpack(hdrfmt,hdr)
  setmetatable(o, self)
  self.__index = self
  return o
end

function PacketReader:next(stream)
  return function()
    local hdr = self.stream:read(16)
    if not hdr or #hdr < 16 then
      return nil
    end
    local sec, frac, inc_len = string.unpack(self.framefmt, hdr)
    local data = self.stream:read(inc_len)
    if not data or #data < inc_len then
      return nil -- if a frame is truncated, skip it and stop iterating
    end
    return sec, frac, data
  end
end

local Scanner = {
  SVC_ROUTE = "./lel/routes.sock",
  SVC_ETHFRAME = "./lel/ethframe.sock",
  SVC_PCAP = "./lel/pcap.sock",
  SVC_STORE = "./lel/stored.sock",
  PPS = 300,
}

function Scanner:new(o)
  o = o or {}
  o.route_sock = ycl.connect(self.SVC_ROUTE)
  o.ethframe_sock = ycl.connect(self.SVC_ETHFRAME)
  o.store_sock = ycl.connect(self.SVC_STORE)
  o.pcap_sock = ycl.connect(self.SVC_PCAP)
  o.msgbuf = ycl.msg()
  setmetatable(o, self)
  self.__index = self
  return o
end

function Scanner:get_netconf()
  self.msgbuf:create_route_req{}
  self.route_sock:sendmsg(self.msgbuf)
  self.route_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_route_resp()
  local routes = ip.unmarshal_routes(resp)
  return netconf_from_routes(routes)
end

function Scanner:print_netconf(netconf)
  for _, entry in pairs(netconf) do
    print("ifname  ", entry.ifname)
    print("ifaddr  ", entry.ifaddr)
    print("ip4_srcs", table.concat(entry.ip4_srcs, " "))
    print("ip6_srcs", table.concat(entry.ip6_srcs, " "))
    print("ip4_dsts", table.concat(entry.ip4_dsts, " "))
    print("---")
  end
end

function Scanner:store_enter(store_id)
  assert(not self.store_id, "attempted entering store more than once")
  self.msgbuf:create_store_enter{
    store_id = store_id,
  }
  self.store_sock:sendmsg(self.msgbuf)
  self.store_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
  store_id = resp.okmsg
  assert(store_id and #store_id > 0, "invalid store ID from service")
  self.store_id = store_id
  return store_id
end

function Scanner:store_open(path, flags, mode)
  assert(self.store_id, "store_open without preceding store_enter")
  self.msgbuf:create_store_open{
    path = path,
    flags = flags,
    mode = mode,
  }
  self.store_sock:sendmsg(self.msgbuf)
  return self.store_sock:recvfd()
end

function Scanner:pcap_start(fd, iface, filter)
  self.msgbuf:create_pcap_req{
    iface = iface,
    filter = filter,
  }
  self.pcap_sock:sendfd(fd)
  self.pcap_sock:sendmsg(self.msgbuf)
  self.pcap_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
  fd:close()
end

function Scanner:send_packets(opts)
  opts.pps = opts.pps or self.PPS
  self.msgbuf:create_ethframe_req(opts)
  self.ethframe_sock:sendmsg(self.msgbuf)
  self.ethframe_sock:recvmsg(self.msgbuf)
  local resp = self.msgbuf:parse_status_resp()
  assert(not resp.errmsg, resp.errmsg)
end

local function main()
  local scanner = Scanner:new() -- setup the scanner
  local params = cgi.init()     -- get env.vars and enter sandbox

  -- setup the store
  local store_id = scanner:store_enter()
  print("STORE   ", store_id)
  print("---")

  -- get the network configuration
  local netconf = scanner:get_netconf()
  scanner:print_netconf(netconf)

  -- send link-local discovery frames for all source addresses
  for _, entry in pairs(netconf) do
    -- setup the capture for this interface (mode: 448 == 0700)
    -- XXX: This filter does not guarantee hosts to be on the local network
    local ifname, ifaddr = entry.ifname, entry.ifaddr
    local fmt = "(not ether src %s) and (arp[6:2] = 2 or icmp or udp or ip6)"
    local filter = string.format(fmt, ifaddr)
    local filename = string.format("disco-%s.pcap", ifname)
    local fd = scanner:store_open(filename, ycl.O_CREAT|ycl.O_WRONLY, 448)
    print(string.format("%s: %s", filename, filter))
    scanner:pcap_start(fd, ifname, filter)
    util.nanosleep(0, 500000000)

    for _, ip4_src in pairs(entry.ip4_srcs) do
      scanner:send_packets{
        iface = ifname,
        categories = "arp-req|ll-disco",
        eth_src = ifaddr,
        ip_src = ip4_src,
        ip_dsts = table.concat(entry.ip4_dsts, " "),
      }
    end
    for _, ip6_src in pairs(entry.ip6_srcs) do
      scanner:send_packets{
        iface = ifname,
        categories = "ll-disco",
        eth_src = ifaddr,
        ip_src = ip6_src,
      }
    end
  end
  util.nanosleep(3,0)

  -- TODO: close current capture (add support for it first)

  -- read captured frames
  for _, entry in pairs(netconf) do
    local ifname, ifaddr = entry.ifname, entry.ifaddr
    local filename = string.format("disco-%s.pcap", ifname)
    local fd = scanner:store_open(filename, ycl.O_RDONLY)
    local stream = fd:to_stream("rb")
    print(fd, stream)
    local packets = PacketReader:open(stream)
    if packets then
      local iter = packets:next()
      local fsec, ffrac, data = iter()
      print(string.format("0.0: %d bytes", #data))
      for sec, frac, data in iter do
        if sec-fsec > 0 then ffrac = 0 end
        print(string.format("%d.%d: %d bytes", sec-fsec, frac-ffrac, #data))
      end
    end
  end
end

main()
