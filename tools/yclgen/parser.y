%{

#include <stdlib.h>
#include <stdio.h>

#define YYERROR_VERBOSE

#define MAX_FIELDS 32

enum field_type {
  FT_DATAARR,
  FT_STRARR,
  FT_INTARR,
  FT_LONGARR,
  FT_DATA,
  FT_STR,
  FT_INT,
  FT_LONG,
};

struct field {
  enum field_type typ;
  char name[32];
};

struct msg {
  struct msg *next;
  char name[32];
  int nfields;
  struct field fields[MAX_FIELDS];
};

struct msg *latest_msg;

extern int yylex();
extern FILE *yyin;

static void push_msg(const char *name);
static void push_field(enum field_type typ, const char *name);
static void free_msgs();
static void yyerror(const char *s);

static int write_header(FILE *fp, struct msg *msgs);
static int write_impl(FILE *fp, struct msg *msgs);

%}

%union {
  char lit[32];
}

%token <lit> LIT
%token DATAARR
%token STRARR
%token INTARR
%token LONGARR
%token DATA
%token STR
%token INT
%token LONG

%%

defs:
  defs def
  | def
  ;

def:
  name '{' fields '}'
  | name '{' '}'
  ;

name:
  LIT  { push_msg($1); }
  ;

fields:
  fields field
  | field
  ;

field:
  DATAARR LIT ';'   {push_field(FT_DATAARR, $2);}
  | STRARR LIT ';'  {push_field(FT_STRARR, $2);}
  | INTARR LIT ';'  {push_field(FT_INTARR, $2);}
  | LONGARR LIT ';' {push_field(FT_LONGARR, $2);}
  | DATA LIT ';'    {push_field(FT_DATA, $2);}
  | STR LIT ';'     {push_field(FT_STR, $2);}
  | INT LIT ';'     {push_field(FT_INT, $2);}
  | LONG LIT ';'    {push_field(FT_LONG, $2);}
  ;

%%

static void usage(const char *name) {
  fprintf(stderr, "usage: %s <out-hdr> <out-impl>\n", name);
  exit(1);
}

int main(int argc, char *argv[]) {
  FILE *outhdr = NULL;
  FILE *outimpl = NULL;
  int status = EXIT_FAILURE;
  int ret;

  if (argc != 3) {
    usage(argv[0]);
  }

  do {
    yyparse();
  } while (!feof(yyin));

  outhdr = fopen(argv[1], "wb");
  if (outhdr == NULL) {
    perror(argv[1]);
    goto out;
  }

  ret = write_header(outhdr, latest_msg);
  if (ret < 0) {
    perror("write_header");
    goto out;
  }

  outimpl = fopen(argv[2], "wb");
  if (outimpl == NULL) {
    perror(argv[2]);
    goto out;
  }

  ret = write_impl(outimpl, latest_msg);
  if (ret < 0) {
    perror("write_impl");
    goto out;
  }

  status = EXIT_SUCCESS;
out:
  if (outhdr != NULL) {
    fclose(outhdr);
  }

  if (outimpl != NULL) {
    fclose(outimpl);
  }
  free_msgs();
  return status;
}

void push_msg(const char *name) {
  struct msg *m;

  m = malloc(sizeof(struct msg));
  if (!m) {
    fprintf(stderr, "out of memory while allocating msg struct\n"),
    exit(1);
  }

  snprintf(m->name, sizeof(m->name), "%s", name);
  m->nfields = 0;
  m->next = latest_msg;
  latest_msg = m;
}

void push_field(enum field_type typ, const char *name) {
  struct msg *m;
  struct field *f;

  m = latest_msg;
  if (!m) {
    fprintf(stderr, "attempt to push field on empty message\n");
    exit(1);
  }

  if (m->nfields >= MAX_FIELDS) {
    fprintf(stderr, "too many fields in message \"%s\"\n", m->name);
    exit(1);
  }

  f = &m->fields[m->nfields];
  f->typ = typ;
  snprintf(f->name, sizeof(f->name), "%s", name);
  m->nfields++;
}

void free_msgs() {
  struct msg *curr;
  struct msg *next;

  for (curr = latest_msg; curr != NULL; curr = next) {
    next = curr->next;
    free(curr);
  }
}

void yyerror(const char *s) {
  fprintf(stderr, "parse error: %s\n", s);
  exit(1);
}

static const char *typ2c(enum field_type t) {
  switch (t) {
  case FT_DATAARR:
    return "struct ycl_data *";
  case FT_STRARR:
    return "const char **";
  case FT_INTARR:
    return "int *";
  case FT_LONGARR:
    return "long *";
  case FT_DATA:
    return "struct ycl_data ";
  case FT_STR:
    return "const char *";
  case FT_INT:
    return "int ";
  case FT_LONG:
    return "long ";
  default:
    return "?err_type?";
  }
}
static int write_struct(FILE *fp, struct msg *msg) {
  struct field *field;
  int ret = 0;
  int i;

  ret = fprintf(fp, "struct ycl_msg_%s {\n", msg->name);
  if (ret < 0) {
    return -1;
  }

  for (i = 0; i < msg->nfields; i++) {
    field = &msg->fields[i];
    ret = fprintf(fp, "  %s%s;\n", typ2c(field->typ), field->name);
    if (ret < 0) {
      return -1;
    }
  }

  ret = fprintf(fp, "};\n\n");
  if (ret < 0) {
    return -1;
  }

  return 0;
}

static int write_fdecl(FILE *fp, struct msg *msg) {
  int ret;

  ret = fprintf(fp, "int ycl_msg_parse_%s(struct ycl_msg *msg, "
      "struct ycl_msg_%s *r);\n"
      "int ycl_msg_create_%s(struct ycl_msg *msg, "
      "struct ycl_msg_%s *r);\n\n",
      msg->name, msg->name, msg->name, msg->name);

  return ret;
}

static int write_header(FILE *fp, struct msg *msgs) {
  int ret;
  struct msg *curr;
  static const char pre[] =
      "/* auto-generated by yclgen - DO NOT EDIT */\n"
      "#ifndef YCLGEN_MSGS_H__\n"
      "#define YCLGEN_MSGS_H__\n"
      "#include <stddef.h>\n\n"
      "struct ycl_data {\n"
      "  size_t len;\n"
      "  const char *data;\n"
      "};\n\n";
  static const char post[] =
      "#endif /* YCLGEN_MSGS_H__ */\n";

  if (fwrite(pre, sizeof(pre)-1, 1, fp) != 1) {
    return -1;
  }

  /* data types */
  for (curr = msgs; curr != NULL; curr = curr->next) {
    ret = write_struct(fp, curr);
    if (ret < 0) {
      return -1;
    }
  }

  /* function declarations */
  for (curr = msgs; curr != NULL; curr = curr->next) {
    ret = write_fdecl(fp, curr);
    if (ret < 0) {
      return -1;
    }
  }

  if (fwrite(post, sizeof(post)-1, 1, fp) != 1) {
    return -1;
  }

  return 0;
}

static int write_impl(FILE *fp, struct msg *msgs) {
  struct msg *curr;

  for (curr = msgs; curr != NULL; curr = curr->next) {

  }

  return 0;
}
